@usecase
<h1>Testes de Software</h1><p>Os testes podem ser classificados de 2 formas: <strong>comportamentais (<em>behavior testing</em>)</strong>&nbsp;ou <strong>estado (<em>state testing</em>)</strong>.<br /><br />Os <strong>testes comportamentais</strong>&nbsp;permitem determinar se as classes e os métodos estão construídos com os nomes e/ou parâmetros corretos. Estes testes validam as interações da aplicação, mas não validam dados (ex: valor devolvido quando um método é invocado).<br /><br />Os <strong>testes de estado</strong>&nbsp;avaliam o estado do objeto através da sua interface. Por exemplo, um teste pode verificar se um método recebe um valor <dfn>null</dfn> num dos parâmetros.</p><p>A <a href="https://www.vogella.com/tutorials/JUnit/article.html" target="_blank" rel="noopener">criação de testes em JUnit</a> é feita recorrendo a um classe para cada Test Case. Um Test Case agrupa um conjunto de testes de uma forma lógica, marcando o papel de cada método com uma anotação. No exemplo seguinte, o teste é marcado por uma anotação <strong>@Test</strong>. As outras anotações são utilizadas para configurar a execução de testes, da seguinte forma:</p><p>- a anotação <strong>@BeforeAll</strong> define que o método marcado vai ser <strong>executado antes de todos os testes</strong> (métodos marcados com <strong>@Test</strong>);</p><p>- a <strong>@BeforeEach</strong> leva à execução do método marcado <strong>antes da execução de cada teste</strong>;</p><p>- a <strong>@AfterEach</strong> e <strong>@AfterAll</strong> leva à execução dos métodos marcados <strong>depois de cada teste</strong> e <strong>depois de todos os testes</strong>, respetivamente.</p><pre>public class TestSingleton {<br />HashMap h;<br /><br /><strong>@BeforeAll</strong><br />public static void setUpBeforeAllTests(){<br />}<br />&nbsp;&nbsp;&nbsp;&nbsp;<br /><strong>@BeforeEach</strong><br />public void setUp(){<br />   h= new HashMap();<br />}<br /><br /><strong>@AfterAll</strong><br />public void tearDown(){<br />}<br /><br /><strong>@AfterEach</strong><br />public void setUp(){<br />}<br /><br /><strong>@Test</strong><br />public void <strong>testNullValue</strong>() {<br />   assertEquals("Path different from null",null,RegistrySingleton.instance().getPath());<br />}<br />}</pre><h3>Exercício</h3><p>Considere a seguinte implementação de uma classe Singleton.</p><pre>package com.es2.singleton;<br /><br />public class Registry {<br />private static Registry object = null;<br />private String path;<br />private String connectionString;<br /><br />private Registry(){}<br /><br />public static Registry getInstance(){<br />   if(object == null) object = new Registry();<br /><br />   return object;<br />}<br /><br />public String getPath() {<br />   return path;<br />}<br /><br />public void setPath(String path) {<br />   this.path = path;<br />}<br /><br />public String getConnectionString() {<br />   return connectionString;<br />}<br /><br />public void setConnectionString(String connectionString) {<br />   this.connectionString = connectionString;<br />}<br />}</pre><p><br />-Crie um teste para verificar se o método <dfn>setPath()</dfn> regista o caminho do ficheiro corretamente.<br />-Crie um teste para verificar se o método <dfn>setConnectionString()</dfn> regista a string de conexão corretamente.<br />-Crie um teste para verificar se o método <dfn>setPath()</dfn> tem o comportamento expectável quanto recebe um valor null.<br />-Crie um teste para verificar se o método <dfn>setConnectionString()</dfn> tem o comportamento expectável quanto recebe um valor null.<br />-Crie um teste para verificar se o construtor da classe <dfn>Singleton()</dfn> é privado. Pode utilizar a expressão <dfn>fail(...)</dfn> para fazer o teste falhar, caso o construtor seja público.</p><p>Submeta a <strong>classe de testes</strong> para validação.</p>
@methods

@deadline
2019-03-24 23:55
@group
es2201819
@exectype
AspectJProject